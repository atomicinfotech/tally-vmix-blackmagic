#include <BMDSDIControl.h>
#include <SPI.h>
#include <Ethernet.h>
#include <EEPROM.h>

int VMIX_PORT = 8099;

#define MAXTALLIES 10

byte inputs[MAXTALLIES];
byte cams[MAXTALLIES];

// Define EEPROM addresses for storing MAC bytes
#define MAC_BYTE_5_ADDRESS 30
#define MAC_BYTE_6_ADDRESS 31

EthernetClient client;
EthernetServer server(80);

BMD_SDITallyControl_I2C sdiTallyControl(0x6E);            // define the Tally object using I2C using the default shield address

byte vmixip[] = { 192, 168, 10, 140 };

// the setup function runs once when you press reset or power the board
void setup()
{
  Serial.begin(115200);

  readsettings();

  pinMode(13, OUTPUT);                                     // initialize digital pin 13 as an output
  
  // Generate or retrieve the MAC address
  byte mac[6];
  getMACAddress(mac);

  Serial.print(F("MAC Address: "));
  for (int i = 0; i < 6; i++) {
    Serial.print(mac[i], HEX);
    if (i < 5) Serial.print(":");
  }
  Serial.println();

  Serial.println(F("Network..."));
  Ethernet.begin(mac);

  delay(2000);

  IPAddress myIPAddress = Ethernet.localIP(); 
  Serial.println(myIPAddress);
    
  vmixconnect();
  
  server.begin();

  sdiTallyControl.begin();                                 // initialize tally control
  sdiTallyControl.setOverride(true);                       // enable tally override
}
    
// the loop function runs over and over again forever
void loop()
{

  while (client.available()) {
    String rawdata = client.readStringUntil('\r\n');
    Serial.println(rawdata);

  
    
   vmixdata(String(rawdata));
  }

  //WEB SERVER
  webclient();
}


void vmixconnect() {
  // vMix connections 
  Serial.println(F("vMix..."));
  Serial.print(vmixip[0]); Serial.print(F(".")); Serial.print(vmixip[1]); Serial.print(F(".")); Serial.print(vmixip[2]); Serial.print(F(".")); Serial.print(vmixip[3]);
   
  Serial.println(VMIX_PORT);
  if(client.connect(vmixip, VMIX_PORT)) {
    Serial.println(F("vMix OK"));
    client.println("SUBSCRIBE TALLY");
  } else {
    Serial.println(F("FAIL"));
  }
}

void vmixdata(String rawdata) {

    Serial.println(F("data is"));
    Serial.println(rawdata);
    Serial.println(rawdata.indexOf("TALLY"));
    
    if (rawdata.indexOf("TALLY") == 0) {
      Serial.println(F("Tally Data"));
  
      String tallydata = rawdata.substring(9);
      Serial.println(tallydata);
  
      int str_len = tallydata.length();
  
      char tallies[str_len];


      tallydata.toCharArray(tallies, str_len);

      for(int i=0;i<15;i++) { //loop through the first fifteen tallies
        tally(tallymap(i + 1),tallies[i]);      
      }
      
    }
  
}

// Function to generate and retrieve MAC address
void getMACAddress(byte *mac)
{
  // Set the first 4 bytes of the MAC address (Arduino OUI)
  mac[0] = 0xA8;
  mac[1] = 0x61;
  mac[2] = 0x0A;
  mac[3] = 0xAE;

  // Check if the last two bytes are stored in EEPROM
  byte byte5 = EEPROM.read(MAC_BYTE_5_ADDRESS);
  byte byte6 = EEPROM.read(MAC_BYTE_6_ADDRESS);

  // If both bytes are 0xFF (default value for empty EEPROM), generate new values
  if (byte5 == 0xFF && byte6 == 0xFF)
  {
    byte5 = random(0x00, 0xFF);
    byte6 = random(0x00, 0xFF);

    // Store the generated bytes in EEPROM
    EEPROM.write(MAC_BYTE_5_ADDRESS, byte5);
    EEPROM.write(MAC_BYTE_6_ADDRESS, byte6);
  }

  // Set the last two bytes of the MAC address
  mac[4] = byte5;
  mac[5] = byte6;
}

void types(String a) { Serial.println(F("it's a String")); }
void types(int a) { Serial.println(F("it's an int")); }
void types(char *a) { Serial.println(F("it's a char*")); }
void types(float a) { Serial.println(F("it's a float")); }
void types(bool a) { Serial.println(F("it's a bool")); }

  
